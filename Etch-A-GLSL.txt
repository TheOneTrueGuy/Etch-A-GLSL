Yes, you can run GLSL shader animations like this one in a Python environment by using libraries that provide OpenGL bindings or abstractions, such as moderngl (with moderngl-window for easier window management and GUI integration), VisPy, or Processing.py (the Python mode of the Processing framework). These allow you to load and execute the GLSL fragment shader, animate it over time, and update parameters dynamically.It's also possible to add real-time control via sliders for parameters (e.g., rotation speed, color hues, iteration counts, or scaling factors in the shader). This can be done by exposing those values as GLSL uniforms and tying them to GUI elements. For an "etch-a-sketch" feel, you could map sliders to adjust fractal complexity or transformations interactively, creating a procedural drawing tool.Below, I'll outline how to do this with moderngl-window (a straightforward choice for Pythonic OpenGL with built-in support for ImGui sliders). It's lightweight and handles the window, rendering loop, and GUI. Note that this assumes Python 3.x; you'd need to install moderngl-window and pyimgui via pip (they're available as of 2025).Step 1: Prepare the GLSL ShaderSave the following as fractal.glsl (expanded from the minified code in the post, with necessary predefined functions from twigl.app). I've added a few custom uniforms (rot_speed, hue_base, scale_factor) for demonstration—you can tweak more values similarly.


#version 330

uniform vec2 resolution;
uniform float time;
uniform float rot_speed;    // New: Control rotation speed
uniform float hue_base;     // New: Base hue for color
uniform float scale_factor; // New: Adjust scaling in the fractal

out vec4 fragColor;

mat3 rotate3D(float angle, vec3 axis) {
    vec3 a = normalize(axis);
    float s = sin(angle);
    float c = cos(angle);
    float r = 1.0 - c;
    return mat3(
        a.x * a.x * r + c, a.y * a.x * r + a.z * s, a.z * a.x * r - a.y * s,
        a.x * a.y * r - a.z * s, a.y * a.y * r + c, a.z * a.y * r + a.x * s,
        a.x * a.z * r + a.y * s, a.y * a.z * r - a.x * s, a.z * a.z * r + c
    );
}

vec3 hsv(float h, float s, float v) {
    vec4 t = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
    vec3 p = abs(fract(vec3(h) + t.xyz) * 6.0 - t.www);
    return v * mix(vec3(1.0), clamp(p - vec3(1.0), 0.0, 1.0), s);
}

void main() {
    vec2 r = resolution;
    float t = time;
    vec4 o = vec4(0.0);
    vec2 FC = gl_FragCoord.xy;

    for (float i = 0.0, g = 0.0, e = 0.0, s = 0.0; ++i < 44.0; ) {
        vec3 p = vec3((FC.xy - 0.5 * r) / r.y * 2.0, g - 0.5) * rotate3D(t * rot_speed, vec3(4.0, 4.0, cos(t * rot_speed)));
        s = 2.0;
        for (int j = 0; j++ < 49; p = vec3(3.0, 4.3, 1.4) - abs(abs(p) * e - vec3(3.7, 2.0, 2.0)))
            s *= e = max(1.0, scale_factor / dot(p, p));
        g += mod(length(p.zx), p.y) / s;
        s = log2(s) / g;
        o.rgb += hsv(hue_base, e - i * 0.07, s / 1e4);
    }

    fragColor = o;
}


Step 2: Python Code for Rendering and SlidersSave this as run_shader.py. It sets up a full-screen quad to render the shader, animates it with time, and adds ImGui sliders for the new uniforms. Run it with python run_shader.py.


import moderngl
import moderngl_window as mglw
from moderngl_window.opengl.vao import VAO

class FractalWindow(mglw.WindowConfig):
    gl_version = (3, 3)
    title = "Fractal Shader Animation"
    window_size = (1280, 720)
    aspect_ratio = 16 / 9
    resizable = True

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        # Load fragment shader
        self.frag_shader = open('fractal.glsl').read()

        # Simple vertex shader for full-screen quad
        self.vert_shader = '''
        #version 330
        in vec2 in_position;
        out vec2 uv;
        void main() {
            uv = (in_position + 1.0) / 2.0;
            gl_Position = vec4(in_position, 0.0, 1.0);
        }
        '''

        # Compile program
        self.prog = self.ctx.program(vertex_shader=self.vert_shader, fragment_shader=self.frag_shader)

        # Full-screen quad geometry
        vertices = [-1.0, -1.0, 1.0, -1.0, -1.0, 1.0, 1.0, 1.0]
        self.quad = VAO(name='quad')
        self.quad.buffer(vertices, '2f', ['in_position'])
        self.quad.index_buffer([0, 1, 2, 1, 3, 2])

        # Initial parameter values
        self.rot_speed = 0.5
        self.hue_base = 0.6
        self.scale_factor = 9.0

    def render(self, time: float, frame_time: float):
        self.ctx.clear(0.0, 0.0, 0.0)
        self.prog['resolution'].value = (self.wnd.width, self.wnd.height)
        self.prog['time'].value = time
        self.prog['rot_speed'].value = self.rot_speed
        self.prog['hue_base'].value = self.hue_base
        self.prog['scale_factor'].value = self.scale_factor
        self.quad.render(self.prog, mode=moderngl.TRIANGLES)

    def imgui_gui(self):
        import imgui
        imgui.begin("Controls")
        _, self.rot_speed = imgui.slider_float("Rotation Speed", self.rot_speed, 0.0, 2.0)
        _, self.hue_base = imgui.slider_float("Base Hue", self.hue_base, 0.0, 1.0)
        _, self.scale_factor = imgui.slider_float("Scale Factor", self.scale_factor, 1.0, 20.0)
        imgui.end()

if __name__ == '__main__':
    mglw.run_window_config(FractalWindow)

How It WorksAnimation: The render method runs in a loop, updating the time uniform for smooth evolution (like the video in the post).
Real-Time Control: ImGui provides sliders in a side panel. Adjusting them instantly updates the uniforms, altering the fractal's behavior (e.g., faster rotation makes it spin quicker, changing scale warps the patterns).
Customization: Add more sliders by defining new uniforms in the GLSL (e.g., uniform float iter_count;) and updating them in Python. For an etch-a-sketch vibe, you could map mouse position to additional uniforms (e.g., camera offset) or add drawing logic on top.
Performance: This runs on the GPU, so it's efficient for real-time fractals. If it's slow, reduce the loop iterations (44 and 49 in the shader).

AlternativesIf you prefer VisPy: It's great for scientific viz. Embed a canvas in a PyQt app, load the shader as a vispy.gloo.Program, and use Qt sliders to update uniforms in a timer callback. See VisPy's real-time data examples for inspiration.
If you want Processing.py: Install Processing and switch to Python mode. Use loadShader('fractal.glsl') in setup(), then in draw(): update uniforms (e.g., shader.set('rot_speed', map(mouseX, 0, width, 0, 2))) and apply with shader(shader); rect(0, 0, width, height);. For proper sliders, integrate a library like controlP5 via Java interop—simpler for quick sketches but less Python-native.

This setup turns the shader into an interactive toy. If you run into issues (e.g., GLSL syntax errors), debug by checking console output or simplifying the shader loops. 


